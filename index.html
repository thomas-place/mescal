<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mescal: 🌵 MeSCaL 🌵</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href=".custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Mescal
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">🌵 MeSCaL 🌵 </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a></p>
<p>**ME**mbership and **S**eparation for **C**l**A**sses of **L**anguages</p>
<p>The aim of this program is to implement most of the known algorithms for deciding membership and separation for prominent classes of regular languages.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Installation</h1>
<p>A <code>Makefile</code> is provided in the src/ folder. It creates an executable file named <code>mescal</code>, which can be executed from that directory with the shell command <code>./mescal</code>.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Requirements</h2>
<p>Currently, the program is <b>experimental</b>. It works on MacOS and Linux. It depends on the following software, which can be installed through <a href="https://brew.sh">homebrew</a> on MacOS, or through apt on Ubuntu or Debian Linux.</p>
<ul>
<li>A C compiler (tested on OSX with Apple clang 15.0.0 to 17.0.0, hardlinked to gcc), with the readline library.</li>
<li>The <a href="https://github.com/json-c">json-c</a> library.</li>
<li>The <a href="https://flintlib.org">flint</a> library.</li>
<li>flex and bison.</li>
<li><a href="https://graphviz.org">Graphviz</a>.</li>
<li>On MacOS: <a href="https://iterm2.com">iTerm</a> with <a href="https://iterm2.com/utilities/imgcat">imgcat</a>.</li>
<li>On Linux: a <a href="https://www.arewesixelyet.com">sixel capable terminal</a>. Tested with <a href="https://konsole.kde.org">Konsole</a>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md3"></a>
Source code documentation</h1>
<p>A Doxygen documentation of the source code is provided <a href="https://thomas-place.github.io/mescal/">here</a>.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Available commands</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
Basic commands</h2>
<h3><a class="anchor" id="autotoc_md6"></a>
General commands</h3>
<pre class="fragment">help                          This help.
timeout                       Displays the current timeout.
timeout = &lt;value&gt;             Sets the timeout to &lt;value&gt; seconds.
limit                         Displays the current limit.
limit = &lt;value&gt;               Sets the limit to &lt;value&gt;.
history                       Displays the current history size.
history = &lt;value&gt;             Sets the history size to &lt;value&gt; entries.
quit or exit                  Quits.
classes                       Lists all classes recognized by the program.
</pre><h3><a class="anchor" id="autotoc_md7"></a>
Using variables</h3>
<pre class="fragment">&lt;variable&gt; = &lt;command&gt;        Stores a copy of the returned object in the variable.
delete(&lt;variable&gt;)            Deletes object.

    Variable types: regular expression, recursive definition of regular expressions, automaton and morphism.
    Variable names: &lt;upper&gt;&lt;upper|digits&gt;*
</pre><h3><a class="anchor" id="autotoc_md8"></a>
Filtering commands</h3>
<pre class="fragment">list(&lt;parameters&gt;)            Lists all stored objects according to the parameters.
regexps(&lt;parameters&gt;)         Lists all stored regular expressions according to the parameters.
automata(&lt;parameters&gt;)        Lists all stored automata according to the parameters.
morphisms(&lt;parameters&gt;)       Lists all stored morphisms according to the parameters.
regexps(&lt;parameters&gt;)         Lists all stored recursive definitions according to the parameters.
</pre><p><b>Available parameters:</b> </p><pre class="fragment">-syntactic                    displays the size of the syntactic monoid.
-syntactic(&lt;n1&gt;,&lt;n2&gt;)         only lists the objects with a syntactic monoid whose size is between n1 and n2.
-idempotents                  displays the number of idempotents in the syntactic monoid.
-idempotents(&lt;n1&gt;,&lt;n2&gt;)       only lists the objects with a syntactic monoid has between n1 and n2 idempotents.
-minimal                      displays the size of the minimal automaton.
-minimal(&lt;n1&gt;,&lt;n2&gt;)           only lists the objects with a minimal automaton whose size is between n1 and n2.
</pre><h3><a class="anchor" id="autotoc_md9"></a>
Sorting commands</h3>
<pre class="fragment">sort                          Sorts all objects, lexicographically by variable name.
sort(&lt;parameter&gt;)             Sorts all objects, according to the ordering given by the parameter.
</pre><p><b>Available parameters:</b> </p><pre class="fragment">-syntactic                    Size of the syntactic monoid
-minimal                      Size of the minimal automaton
</pre><h3><a class="anchor" id="autotoc_md10"></a>
Saving and loading</h3>
<pre class="fragment">save(&lt;command&gt;,"&lt;filename&gt;")  Saves the object returned by a command in a file.
open("&lt;filename&gt;")            Opens and returns an object stored in a file.
savesession("&lt;filename&gt;")     Saves all current objects in a file.
loadsession("&lt;filename&gt;")     Loads all current objects from a file.
</pre><h2><a class="anchor" id="autotoc_md11"></a>
Using regular expressions variables</h2>
<h3><a class="anchor" id="autotoc_md12"></a>
Definition, of a regular expression</h3>
<pre class="fragment">"&lt;regexp&gt;"

Syntax of regexps:
   e := e + e | e e | e* | !e | (e) | e &amp; e | \1 | \0
 where,
   0 = ∅, 1 = ε, ! = complement, &amp; = ∩
</pre><h3><a class="anchor" id="autotoc_md13"></a>
Manipulation of a regular expression stored in a variable L</h3>
<pre class="fragment">L                             Displays the regular expression.
L.minimal                     The minimal automaton: works as an automaton variable.
L.syntactic                   The syntactic morphism: works as a morphism variable.
thomson(L)                    Uses the Thomson algorithm to compute a NFA.
glushkov(L)                   Uses the Glushkov algorithm to compute a NFA.
</pre><h2><a class="anchor" id="autotoc_md14"></a>
Using recurvive definitions variables</h2>
<h3><a class="anchor" id="autotoc_md15"></a>
Initialization</h3>
<pre class="fragment">initrecursion(&lt;n&gt;,&lt;v1&gt;,...)   Returns an initialized recursive definition variable.
                              &lt;n&gt; is the largest index that has to be specified by the user.
                              &lt;v1&gt;,... is a list of variable names denoting the relations used in the recursive definition.
                              Example: R = initrecursion(0,L)
</pre><h3><a class="anchor" id="autotoc_md16"></a>
Setup of an initialized recursive definition variable R</h3>
<pre class="fragment">E.&lt;v&gt;[&lt;n&gt;] = &lt;regexp&gt;         Defines the initial case &lt;n&gt; of the relation &lt;v&gt;.
                              (&lt;n&gt; must be smaller than the maximum index specified in the initialization).
                              Example: R.L[0] = "\1"

E.&lt;v&gt;[i] = &lt;symbolic regexp&gt;  Defines the recursion of the relation &lt;v&gt;.
                              The regular expression can use symbolic variables and letters.
                              Example: R.L[i] = "(a{L}[i-1]b)*"
</pre><p><b>Syntax of symbolic regexps:</b> </p><pre class="fragment">e := e + e | e e | e* | !e | (e) | e &amp; e | \1 | \0 | a[i - &lt;n&gt;] | {&lt;v&gt;}[i - &lt;n&gt;]
    where,
0 = ∅, 1 = ε, ! = complement, &amp; = ∩, a[i - &lt;n&gt;] = symbolic letter, {&lt;v&gt;}[i - &lt;n&gt;] = symbolic variable
</pre><h3><a class="anchor" id="autotoc_md17"></a>
Usage of a recursive definition variable R</h3>
<pre class="fragment">R                             Displays the recursive definition and checks if it is well-defined.
R.&lt;v&gt;[&lt;n&gt;]                    Returns the regular expression of index &lt;n&gt; for the relation &lt;v&gt;.
                              (can be copied into a regular expression variable).
</pre><h2><a class="anchor" id="autotoc_md18"></a>
Using variables representing automata</h2>
<h3><a class="anchor" id="autotoc_md19"></a>
Manipulation of an automaton stored in a variable A</h3>
<pre class="fragment">A                             Displays the automaton.
A.minimal                     The minimal automaton: works as an automaton variable.
latex(A.minimal)              The minimal automaton, printed in LaTeX.
A.syntactic                   The syntactic morphism: works as a morphism variable.
latex(A.syntactic)            The right Cayley graph of the minimal automaton, printed in LaTeX.
elimepsilon(A)                Builds a new automaton by eliminating the epsilon transitions.
trim(A)                       Builds a new automaton by eliminating the tates that are not accessible or co-accessible.
union(A1,A2)                  Builds a new automaton by making a nondeterministic union.
intersection(A1,A2)           Builds a new automaton by making an intersection.
concatenation(A1,A2)          Builds a new automaton by making a concatenation.
kleene(A)                     Builds a new automaton by applying a Kleene star.
mccluskey(A)                  Uses the Brzozowski-McCluskey algorithm to compute a regular expression.
brzozowski(A)                 Uses the Brzozowski algorithm to compute a minimal NFA.
hopcroft(A)                   Uses the Hopcroft algorithm to compute a minimal NFA.
nfarandom(&lt;n1&gt;,&lt;n2&gt;,&lt;n3&gt;)     Builds a random NFA over an alphabet of size &lt;n1&gt; with at least &lt;n2&gt; states and at most &lt;n3&gt; states.
dfarandom(&lt;n1&gt;,&lt;n2&gt;,&lt;n3&gt;)     Builds a random complete DFA over an alphabet of size &lt;n1&gt; with at least &lt;n2&gt; states and at most &lt;n3&gt; states.
run(A,"&lt;word&gt;")               Computes the set of states reached with an input word.
iextension(A)                 Applies inverse extension to the automaton (does not return an object).
dyckextension(A)              Builds a new automaton via Dyck extension.
counterfree(A)                Tests if the automaton is a counterfree DFA.
permutation(A)                Tests if the automaton is a permutation DFA.
</pre><h2><a class="anchor" id="autotoc_md20"></a>
Using morphisms variables</h2>
<h3><a class="anchor" id="autotoc_md21"></a>
Manipulation of a morphism stored in a variable M</h3>
<pre class="fragment">M                             Displays the Green relations of the monoid.
rcayley(M)                    Displays the right Cayley graph of the morphism.
lcayley(M)                    Displays the left Cayley graph of the morphism.
multiplication(M)             Displays the multiplication table of the monoid.
order(M)                      Displays the ordering defined on the monoid.
idempotents(M)                Displays the idempotents of the monoid.
mkernel(M)                    Displays the MOD-kernel of the morphism.
akernel(M)                    Displays the AMT-kernel of the morphism.
gkernel(M)                    Displays the GR-kernel of the morphism.
orbit(𝒞,M)                    Displays the 𝒞-orbits for the morphism (implemented for 𝒞 = DD, MOD⁺, AT).
orbit(𝒞,M,e)                  Displays the 𝒞-orbit of the idempotent e for the morphism (implemented for 𝒞 = DD, MOD⁺, AT).
orbit(OP,𝒞,M)                 Displays the OP(𝒞)-orbits for the morphism (implemented for OP = BPol, TL and 𝒞 = ST, DD, MOD, MOD⁺, GR, GR⁺).
orbit(OP,𝒞,M,e)               Displays the OP(𝒞)-orbits of the idempotent e for the morphism (implemented for OP = BPol, TL and 𝒞 = ST, DD, MOD, MOD⁺, GR, GR⁺).
image(M,"&lt;word&gt;")             Computes the image of an input word.
</pre><h2><a class="anchor" id="autotoc_md22"></a>
Membership tests</h2>
<pre class="fragment">- membership(𝒞,&lt;object&gt;)                            
      Checks if the language recognized by the object belongs to 𝒞 (example: membership(Pol(GR),L)).
- exall(𝒞,𝒟,&lt;n1&gt;,&lt;n2&gt;)                              
      Computes and stores in variables all DFAs with at most &lt;n1&gt; states (plus a sink state) 
      and &lt;n2&gt; letters which are outside 𝒞 and inside 𝒟.
- exall(out(𝒞₁,..,𝒞ₙ),in(𝒟₁,..,𝒟ₘ),&lt;n1&gt;,&lt;n2&gt;)
      Computes and stores in variables all DFAs with at most &lt;n1&gt; states (plus a sink state) 
      and &lt;n2&gt; letters which are outside 𝒞₁,..,𝒞ₙ and inside 𝒟₁,..,𝒟ₘ.
</pre><h3><a class="anchor" id="autotoc_md23"></a>
Available classes 𝒞</h3>
<pre class="fragment">- ST      Trivial class.
- DD      Well-suited extension of ST (DD = ST⁺).
- MOD     Modulo languages.
- MODP    Well-suited extension of the modulo languages (MODP = MOD⁺).
- AMT     Alphabet modulo testable languages.
- AMTP    Well-suited extension of the alphabet modulo languages (AMTP = AMT⁺).
- GR      Group languages.
- GRP     Well-suited extension of the group languages (GRP = GR⁺).
- AT      Alphabet testable languages.
- ATT     Alphabet threshold testable languages.
- LT      Locally testable languages.
- LTT     Locally threshold testable languages.
- PPT     Positive piecewise testable languages.
- PT      Piecewise testable languages.
- SF      Star-free languages.
- UL      Unambiguous languages.
</pre><h3><a class="anchor" id="autotoc_md24"></a>
Available operators OP</h3>
<pre class="fragment">- Pol     Polynomial closure : 𝒞 ↦ Pol(𝒞).
- BPol    Boolean polynomial closure : 𝒞 ↦ BPol(𝒞).
- UBPol   Combined operator : 𝒞 ↦ UPol(BPol(𝒞)).
- Pol2    Combined operator : 𝒞 ↦ Pol(BPol(𝒞)).
- BPol2   Combined operator : 𝒞 ↦ BPol(BPol(𝒞)).
- UBPol2  Combined operator : 𝒞 ↦ UPol(BPol(BPol(𝒞))).
- FL      Future unary temporal logic closure : 𝒞 ↦ FL(𝒞).
- FL2     Combined operator : 𝒞 ↦ FL(FL(𝒞)).
- PL      Past unary temporal logic closure : 𝒞 ↦ PL(𝒞).
- PL2     Combined operator : 𝒞 ↦ PL(PL(𝒞)).
- TL      Unary temporal logic closure (𝒞 ↦ TL(𝒞)).
- TL2     Combined operator : 𝒞 ↦ TL(TL(𝒞)).
- SF      Star-free closure : 𝒞 ↦ SF(𝒞).

chierarchies(&lt;object&gt;)        Summary of membership tests for the language recognized by the object in concatenation hierarchies.
nhierarchies(𝒞,&lt;object&gt;)      If the language recognized by the object belongs to TL(𝒞), determines its level in the negation hierarchy of TL(𝒞).
fphierarchies(𝒞,&lt;object&gt;)     If the language recognized by the object belongs to TL(𝒞), determines its level in the future/past hierarchy of TL(𝒞).
</pre><h3><a class="anchor" id="autotoc_md25"></a>
Available input classes 𝒞 for negation hierarchies and future/past hierarchies</h3>
<pre class="fragment">- ST      Trivial class.
- DD      Well-suited extension of ST (DD = ST⁺).
- MOD     Modulo languages.
- MODP    Well-suited extension of the modulo languages (MODP = MOD⁺).
- GR      Group languages.
</pre><h2><a class="anchor" id="autotoc_md26"></a>
Separation tests</h2>
<pre class="fragment">- separ(𝒞,&lt;o1&gt;,&lt;o2&gt;,(info))     Checks if &lt;o1&gt; is 𝒞-separable from &lt;o2&gt; ("info" is an optional parameter, it asks for more details).
</pre><h3><a class="anchor" id="autotoc_md27"></a>
Available classes 𝒞</h3>
<pre class="fragment">- ST      Trivial class.
- MOD     Modulo languages.
- GR      Group languages.
</pre><h3><a class="anchor" id="autotoc_md28"></a>
Available operators OP</h3>
<pre class="fragment">- Pol     Polynomial closure (𝒞 ↦ Pol(𝒞)).
</pre> </div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
