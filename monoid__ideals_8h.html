<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mescal: monoid_ideals.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href=".custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Mescal
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('monoid__ideals_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">monoid_ideals.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Computations of ideals in monoids.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;<a class="el" href="monoid_8h_source.html">monoid.h</a>&quot;</code><br />
</div>
<p><a href="monoid__ideals_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a65e39e79d0877df130a79151c5b1e958" id="r_a65e39e79d0877df130a79151c5b1e958"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdequeue.html">dequeue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65e39e79d0877df130a79151c5b1e958">compute_r_ideal</a> (<a class="el" href="structmorphism.html">morphism</a> *, uint, bool *)</td></tr>
<tr class="memdesc:a65e39e79d0877df130a79151c5b1e958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of the right ideal of an element.  <br /></td></tr>
<tr class="separator:a65e39e79d0877df130a79151c5b1e958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309ac88d54d140951c7c6700badb920e" id="r_a309ac88d54d140951c7c6700badb920e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdequeue.html">dequeue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a309ac88d54d140951c7c6700badb920e">compute_l_ideal</a> (<a class="el" href="structmorphism.html">morphism</a> *, uint, bool *)</td></tr>
<tr class="memdesc:a309ac88d54d140951c7c6700badb920e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of the left ideal of an element.  <br /></td></tr>
<tr class="separator:a309ac88d54d140951c7c6700badb920e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d1881d821537433c40060e32e8bf97" id="r_aa7d1881d821537433c40060e32e8bf97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdequeue.html">dequeue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7d1881d821537433c40060e32e8bf97">compute_j_ideal</a> (<a class="el" href="structmorphism.html">morphism</a> *, uint, bool *)</td></tr>
<tr class="memdesc:aa7d1881d821537433c40060e32e8bf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of the two-sided ideal of an element.  <br /></td></tr>
<tr class="separator:aa7d1881d821537433c40060e32e8bf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e77c2c79ba0c3db5f275fef2681405c" id="r_a3e77c2c79ba0c3db5f275fef2681405c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdequeue.html">dequeue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e77c2c79ba0c3db5f275fef2681405c">compute_r_ideal_alph</a> (<a class="el" href="structmorphism.html">morphism</a> *, uint, bool *, bool *)</td></tr>
<tr class="memdesc:a3e77c2c79ba0c3db5f275fef2681405c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of a given restricted right ideal of an element. The restriction is given by a sub-alphabet: the only available transitions are those labeled by a letter in this sub-alphabet.  <br /></td></tr>
<tr class="separator:a3e77c2c79ba0c3db5f275fef2681405c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982fc0b0481b6ae6de49958e4b272983" id="r_a982fc0b0481b6ae6de49958e4b272983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdequeue.html">dequeue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a982fc0b0481b6ae6de49958e4b272983">compute_l_ideal_alph</a> (<a class="el" href="structmorphism.html">morphism</a> *, uint, bool *, bool *)</td></tr>
<tr class="memdesc:a982fc0b0481b6ae6de49958e4b272983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of a given restricted left ideal of an element. The restriction is given by a sub-alphabet: the only available transitions are those labeled by a letter in this sub-alphabet.  <br /></td></tr>
<tr class="separator:a982fc0b0481b6ae6de49958e4b272983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18b7781ca36b6a192432adacfbb1d01" id="r_ab18b7781ca36b6a192432adacfbb1d01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdequeue.html">dequeue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab18b7781ca36b6a192432adacfbb1d01">compute_j_ideal_alph</a> (<a class="el" href="structmorphism.html">morphism</a> *, uint, bool *, bool *)</td></tr>
<tr class="memdesc:ab18b7781ca36b6a192432adacfbb1d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of a given restricted left/right ideal of an element. The restriction is given by a sub-alphabet: the only available transitions are those labeled by a letter in this sub-alphabet.  <br /></td></tr>
<tr class="separator:ab18b7781ca36b6a192432adacfbb1d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af723c8001a8cba777e0d24d3cc38a27f" id="r_af723c8001a8cba777e0d24d3cc38a27f"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af723c8001a8cba777e0d24d3cc38a27f">get_rlink</a> (<a class="el" href="structmorphism.html">morphism</a> *, <a class="el" href="structparti.html">parti</a> *, uint, uint)</td></tr>
<tr class="memdesc:af723c8001a8cba777e0d24d3cc38a27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an idempotent g and an element q such that g R q, compute an element s such that g = qr.  <br /></td></tr>
<tr class="separator:af723c8001a8cba777e0d24d3cc38a27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3be6d524e6b4539cd6d979a43b1fad" id="r_aac3be6d524e6b4539cd6d979a43b1fad"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac3be6d524e6b4539cd6d979a43b1fad">get_llink</a> (<a class="el" href="structmorphism.html">morphism</a> *, <a class="el" href="structparti.html">parti</a> *, uint, uint)</td></tr>
<tr class="memdesc:aac3be6d524e6b4539cd6d979a43b1fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an idempotent h and an element t such that h R t, compute an element s such that h = st.  <br /></td></tr>
<tr class="separator:aac3be6d524e6b4539cd6d979a43b1fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Computations of ideals in monoids. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa7d1881d821537433c40060e32e8bf97" name="aa7d1881d821537433c40060e32e8bf97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d1881d821537433c40060e32e8bf97">&#9670;&#160;</a></span>compute_j_ideal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdequeue.html">dequeue</a> * compute_j_ideal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmorphism.html">morphism</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computation of the two-sided ideal of an element. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The third parameter is an array of Booleans indexed by the elements of the monoid. It restricts the elements in the returned list to those which are marked true by the array. When no restriction is needed a NULL pointer should be given as input.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The two-sided ideal sorted in increasing order. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The morphism.  </td></tr>
    <tr><td class="paramname">s</td><td>The element  </td></tr>
    <tr><td class="paramname">rest</td><td>An array of Booleans indexed by the elements. Can be used to restrict the output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab18b7781ca36b6a192432adacfbb1d01" name="ab18b7781ca36b6a192432adacfbb1d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18b7781ca36b6a192432adacfbb1d01">&#9670;&#160;</a></span>compute_j_ideal_alph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdequeue.html">dequeue</a> * compute_j_ideal_alph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmorphism.html">morphism</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>alph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computation of a given restricted left/right ideal of an element. The restriction is given by a sub-alphabet: the only available transitions are those labeled by a letter in this sub-alphabet. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The fourth parameter is an array of Booleans indexed by the elements of the monoid. It restricts the elements in the returned list to those which are marked true by the array. When no restriction is needed a NULL pointer should be given as input.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The restricted left ideal sorted in increasing order. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The morphism.  </td></tr>
    <tr><td class="paramname">s</td><td>The element  </td></tr>
    <tr><td class="paramname">alph</td><td>An array of Booleans indexed by the letters. Marks the letters inside the sub-alphabet  </td></tr>
    <tr><td class="paramname">rest</td><td>An array of Booleans indexed by the elements. Can be used to restrict the output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a309ac88d54d140951c7c6700badb920e" name="a309ac88d54d140951c7c6700badb920e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309ac88d54d140951c7c6700badb920e">&#9670;&#160;</a></span>compute_l_ideal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdequeue.html">dequeue</a> * compute_l_ideal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmorphism.html">morphism</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computation of the left ideal of an element. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The third parameter is an array of Booleans indexed by the elements of the monoid. It restricts the elements in the returned list to those which are marked true by the array. When no restriction is needed a NULL pointer should be given as input.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The left ideal sorted in increasing order. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The morphism.  </td></tr>
    <tr><td class="paramname">s</td><td>The element  </td></tr>
    <tr><td class="paramname">rest</td><td>An array of Booleans indexed by the elements. Can be used to restrict the output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a982fc0b0481b6ae6de49958e4b272983" name="a982fc0b0481b6ae6de49958e4b272983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982fc0b0481b6ae6de49958e4b272983">&#9670;&#160;</a></span>compute_l_ideal_alph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdequeue.html">dequeue</a> * compute_l_ideal_alph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmorphism.html">morphism</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>alph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computation of a given restricted left ideal of an element. The restriction is given by a sub-alphabet: the only available transitions are those labeled by a letter in this sub-alphabet. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The fourth parameter is an array of Booleans indexed by the elements of the monoid. It restricts the elements in the returned list to those which are marked true by the array. When no restriction is needed a NULL pointer should be given as input.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The restricted left ideal sorted in increasing order. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The morphism.  </td></tr>
    <tr><td class="paramname">s</td><td>The element  </td></tr>
    <tr><td class="paramname">alph</td><td>An array of Booleans indexed by the letters. Marks the letters inside the sub-alphabet  </td></tr>
    <tr><td class="paramname">rest</td><td>An array of Booleans indexed by the elements. Can be used to restrict the output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65e39e79d0877df130a79151c5b1e958" name="a65e39e79d0877df130a79151c5b1e958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e39e79d0877df130a79151c5b1e958">&#9670;&#160;</a></span>compute_r_ideal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdequeue.html">dequeue</a> * compute_r_ideal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmorphism.html">morphism</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computation of the right ideal of an element. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The third parameter is an array of Booleans indexed by the elements of the monoid. It restricts the elements in the returned list to those which are marked true by the array. When no restriction is needed a NULL pointer should be given as input.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The right ideal sorted in increasing order. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The morphism.  </td></tr>
    <tr><td class="paramname">s</td><td>The element  </td></tr>
    <tr><td class="paramname">rest</td><td>An array of Booleans indexed by the elements. Can be used to restrict the output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e77c2c79ba0c3db5f275fef2681405c" name="a3e77c2c79ba0c3db5f275fef2681405c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e77c2c79ba0c3db5f275fef2681405c">&#9670;&#160;</a></span>compute_r_ideal_alph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdequeue.html">dequeue</a> * compute_r_ideal_alph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmorphism.html">morphism</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>alph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computation of a given restricted right ideal of an element. The restriction is given by a sub-alphabet: the only available transitions are those labeled by a letter in this sub-alphabet. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The fourth parameter is an array of Booleans indexed by the elements of the monoid. It restricts the elements in the returned list to those which are marked true by the array. When no restriction is needed a NULL pointer should be given as input.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The restricted right ideal sorted in increasing order. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The morphism.  </td></tr>
    <tr><td class="paramname">s</td><td>The element  </td></tr>
    <tr><td class="paramname">alph</td><td>An array of Booleans indexed by the letters. Marks the letters inside the sub-alphabet  </td></tr>
    <tr><td class="paramname">rest</td><td>An array of Booleans indexed by the elements. Can be used to restrict the output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac3be6d524e6b4539cd6d979a43b1fad" name="aac3be6d524e6b4539cd6d979a43b1fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3be6d524e6b4539cd6d979a43b1fad">&#9670;&#160;</a></span>get_llink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint get_llink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmorphism.html">morphism</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structparti.html">parti</a> *</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an idempotent h and an element t such that h R t, compute an element s such that h = st. </p>
<dl class="section return"><dt>Returns</dt><dd>The element s. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The morphism.  </td></tr>
    <tr><td class="paramname">L</td><td>The L-classes.  </td></tr>
    <tr><td class="paramname">h</td><td>Idempotent.  </td></tr>
    <tr><td class="paramname">t</td><td>Start element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af723c8001a8cba777e0d24d3cc38a27f" name="af723c8001a8cba777e0d24d3cc38a27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af723c8001a8cba777e0d24d3cc38a27f">&#9670;&#160;</a></span>get_rlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint get_rlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmorphism.html">morphism</a> *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structparti.html">parti</a> *</td>          <td class="paramname"><span class="paramname"><em>R</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an idempotent g and an element q such that g R q, compute an element s such that g = qr. </p>
<dl class="section return"><dt>Returns</dt><dd>The element r. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The morphism.  </td></tr>
    <tr><td class="paramname">R</td><td>The R-classes.  </td></tr>
    <tr><td class="paramname">g</td><td>Idempotent.  </td></tr>
    <tr><td class="paramname">r</td><td>Start element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="monoid__ideals_8h.html">monoid_ideals.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
