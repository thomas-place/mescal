<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mescal: regexp.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href=".custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Mescal
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('regexp_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">regexp.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implementation of regular expressions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="alloc_8h_source.html">alloc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="error_8h_source.html">error.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="nfa_8h_source.html">nfa.h</a>&quot;</code><br />
<code>#include &quot;tools.h&quot;</code><br />
<code>#include &quot;<a class="el" href="type__basic_8h_source.html">type_basic.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="type__dequeue_8h_source.html">type_dequeue.h</a>&quot;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div>
<p><a href="regexp_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyletter.html">syletter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent a symbolic letter.  <a href="structsyletter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyvariable.html">syvariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent a symbolic variable.  <a href="structsyvariable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregexp.html">regexp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent a single node in a regular expression.  <a href="structregexp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abf63ec5e1854cf5d949e10f992bbeb3f" id="r_abf63ec5e1854cf5d949e10f992bbeb3f"><td class="memItemLeft" align="right" valign="top"><a id="abf63ec5e1854cf5d949e10f992bbeb3f" name="abf63ec5e1854cf5d949e10f992bbeb3f"></a>
typedef struct syletter&#160;</td><td class="memItemRight" valign="bottom"><b>syletter</b></td></tr>
<tr class="memdesc:abf63ec5e1854cf5d949e10f992bbeb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent a symbolic letter. <br /></td></tr>
<tr class="separator:abf63ec5e1854cf5d949e10f992bbeb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ba0ad226a535f77dfd561711ec9e0e" id="r_a53ba0ad226a535f77dfd561711ec9e0e"><td class="memItemLeft" align="right" valign="top"><a id="a53ba0ad226a535f77dfd561711ec9e0e" name="a53ba0ad226a535f77dfd561711ec9e0e"></a>
typedef struct syvariable&#160;</td><td class="memItemRight" valign="bottom"><b>syvariable</b></td></tr>
<tr class="memdesc:a53ba0ad226a535f77dfd561711ec9e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent a symbolic variable. <br /></td></tr>
<tr class="separator:a53ba0ad226a535f77dfd561711ec9e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c7f4f28bd4645dbcab031dc7e8420b" id="r_ab9c7f4f28bd4645dbcab031dc7e8420b"><td class="memItemLeft" align="right" valign="top"><a id="ab9c7f4f28bd4645dbcab031dc7e8420b" name="ab9c7f4f28bd4645dbcab031dc7e8420b"></a>
typedef struct regexp&#160;</td><td class="memItemRight" valign="bottom"><b>regexp</b></td></tr>
<tr class="memdesc:ab9c7f4f28bd4645dbcab031dc7e8420b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent a single node in a regular expression. <br /></td></tr>
<tr class="separator:ab9c7f4f28bd4645dbcab031dc7e8420b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a945e1b6cec6225bade72691d362c68fa" id="r_a945e1b6cec6225bade72691d362c68fa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a945e1b6cec6225bade72691d362c68fa">regelem</a> { <br />
&#160;&#160;<a class="el" href="#a945e1b6cec6225bade72691d362c68faa2f0d18fc0d0fa4a6cd92dc328501874d">EMPTY</a>
, <a class="el" href="#a945e1b6cec6225bade72691d362c68faa1fa5920d8d419e0b8036e2dbada9a882">EPSILON</a>
, <a class="el" href="#a945e1b6cec6225bade72691d362c68faa4618cf21306b3c647741afa7ebefcab8">CHAR</a>
, <a class="el" href="#a945e1b6cec6225bade72691d362c68faa232dbc82ab82a68986004c87d9b59118">SYCHAR</a>
, <br />
&#160;&#160;<a class="el" href="#a945e1b6cec6225bade72691d362c68faac603be6458810921e4e3b03672fc1ea3">SYVAR</a>
, <a class="el" href="#a945e1b6cec6225bade72691d362c68faa4ad40322037d6d371dca3e5cf993f5dc">WORD</a>
, <a class="el" href="#a945e1b6cec6225bade72691d362c68faa4cf5e96eb7880eb38df303a6e5759afd">UNION</a>
, <a class="el" href="#a945e1b6cec6225bade72691d362c68faa5efa5610d5a2c5e9123d6894dd72e335">INTER</a>
, <br />
&#160;&#160;<a class="el" href="#a945e1b6cec6225bade72691d362c68faa09a24ada4cada9fedf84fbcfd5dc0511">COMPLEMENT</a>
, <a class="el" href="#a945e1b6cec6225bade72691d362c68faa9044fbb1b4b9307bcd680468a58c22f2">CONCAT</a>
, <a class="el" href="#a945e1b6cec6225bade72691d362c68faa9d398750ed310ae69cd070016810e4dc">STAR</a>
, <a class="el" href="#a945e1b6cec6225bade72691d362c68faa87fe59ef12c3d13dc2a4d14c9b16c1f9">PLUS</a>
, <br />
&#160;&#160;<a class="el" href="#a945e1b6cec6225bade72691d362c68faac157bdf0b85a40d2619cbc8bc1ae5fe2">NONE</a>
<br />
 }</td></tr>
<tr class="memdesc:a945e1b6cec6225bade72691d362c68fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operator available in an extended regular expression.  <a href="#a945e1b6cec6225bade72691d362c68fa">More...</a><br /></td></tr>
<tr class="separator:a945e1b6cec6225bade72691d362c68fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a935e36a4d7114dc9f40109f1b234ba66" id="r_a935e36a4d7114dc9f40109f1b234ba66"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a935e36a4d7114dc9f40109f1b234ba66">symbolic_index</a> (char *)</td></tr>
<tr class="memdesc:a935e36a4d7114dc9f40109f1b234ba66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the index of a symbolic variable name in the array symbolic_names.  <br /></td></tr>
<tr class="separator:a935e36a4d7114dc9f40109f1b234ba66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc822beda3f58d0f381de94ef6478d8a" id="r_afc822beda3f58d0f381de94ef6478d8a"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc822beda3f58d0f381de94ef6478d8a">display_syletter_utf8</a> (<a class="el" href="structsyletter.html">syletter</a>, FILE *)</td></tr>
<tr class="memdesc:afc822beda3f58d0f381de94ef6478d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays a symbolic letter on a given stream: UTF8 version for the indices.  <br /></td></tr>
<tr class="separator:afc822beda3f58d0f381de94ef6478d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e30e80bbc958492e10d8bd761ee096" id="r_aa1e30e80bbc958492e10d8bd761ee096"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1e30e80bbc958492e10d8bd761ee096">display_syvar_utf8</a> (<a class="el" href="structsyvariable.html">syvariable</a> v, FILE *out)</td></tr>
<tr class="memdesc:aa1e30e80bbc958492e10d8bd761ee096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays a symbolic variable on a given stream: UTF8 version for the indices.  <br /></td></tr>
<tr class="separator:aa1e30e80bbc958492e10d8bd761ee096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2782e3c0fdb39fe6d1181a5775e240a" id="r_ab2782e3c0fdb39fe6d1181a5775e240a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2782e3c0fdb39fe6d1181a5775e240a">reg_has_symbolic</a> (<a class="el" href="structregexp.html">regexp</a> *)</td></tr>
<tr class="memdesc:ab2782e3c0fdb39fe6d1181a5775e240a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if a regular expression contains a symbolic node.  <br /></td></tr>
<tr class="separator:ab2782e3c0fdb39fe6d1181a5775e240a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9ac023e7d3f1ceb95c4ca5d3386ff7" id="r_aed9ac023e7d3f1ceb95c4ca5d3386ff7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed9ac023e7d3f1ceb95c4ca5d3386ff7">reg_issimple</a> (<a class="el" href="structregexp.html">regexp</a> *)</td></tr>
<tr class="memdesc:aed9ac023e7d3f1ceb95c4ca5d3386ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if a regular expression is simple.  <br /></td></tr>
<tr class="separator:aed9ac023e7d3f1ceb95c4ca5d3386ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c7ffc70fec6309a28b393380d505f0" id="r_aa4c7ffc70fec6309a28b393380d505f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4c7ffc70fec6309a28b393380d505f0">reg_free</a> (<a class="el" href="structregexp.html">regexp</a> *)</td></tr>
<tr class="memdesc:aa4c7ffc70fec6309a28b393380d505f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release of a regular expression.  <br /></td></tr>
<tr class="separator:aa4c7ffc70fec6309a28b393380d505f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420113f0cc33a6dc7b6eb2abd3ac9a43" id="r_a420113f0cc33a6dc7b6eb2abd3ac9a43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregexp.html">regexp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a420113f0cc33a6dc7b6eb2abd3ac9a43">reg_copy</a> (<a class="el" href="structregexp.html">regexp</a> *)</td></tr>
<tr class="memdesc:a420113f0cc33a6dc7b6eb2abd3ac9a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy of a regular expression.  <br /></td></tr>
<tr class="separator:a420113f0cc33a6dc7b6eb2abd3ac9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba9e7fdf196326ddc67a7e7b8ce221b" id="r_a2ba9e7fdf196326ddc67a7e7b8ce221b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregexp.html">regexp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ba9e7fdf196326ddc67a7e7b8ce221b">reg_empty</a> (void)</td></tr>
<tr class="memdesc:a2ba9e7fdf196326ddc67a7e7b8ce221b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a regular expression recognizing the empty language.  <br /></td></tr>
<tr class="separator:a2ba9e7fdf196326ddc67a7e7b8ce221b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2092d5f621e571c562a90c097e7e56c9" id="r_a2092d5f621e571c562a90c097e7e56c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregexp.html">regexp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2092d5f621e571c562a90c097e7e56c9">reg_epsilon</a> (void)</td></tr>
<tr class="memdesc:a2092d5f621e571c562a90c097e7e56c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a regular expression recognizing the language {ε}.  <br /></td></tr>
<tr class="separator:a2092d5f621e571c562a90c097e7e56c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e86a288e33a52e8e0fd42eaf76435ab" id="r_a1e86a288e33a52e8e0fd42eaf76435ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregexp.html">regexp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e86a288e33a52e8e0fd42eaf76435ab">reg_letter</a> (uchar)</td></tr>
<tr class="memdesc:a1e86a288e33a52e8e0fd42eaf76435ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a regular expression recognizing the language {a} for an input letter a.  <br /></td></tr>
<tr class="separator:a1e86a288e33a52e8e0fd42eaf76435ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5a5a4ec95a5e07499917e03b8e37f6" id="r_a6f5a5a4ec95a5e07499917e03b8e37f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregexp.html">regexp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f5a5a4ec95a5e07499917e03b8e37f6">reg_letter_ext</a> (<a class="el" href="structletter.html">letter</a>)</td></tr>
<tr class="memdesc:a6f5a5a4ec95a5e07499917e03b8e37f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a regular expression recognizing the language {a} for an input letter a. Extended version.  <br /></td></tr>
<tr class="separator:a6f5a5a4ec95a5e07499917e03b8e37f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0446501d5eb553d8f2e4f488feec53" id="r_adf0446501d5eb553d8f2e4f488feec53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregexp.html">regexp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf0446501d5eb553d8f2e4f488feec53">reg_letter_numbered</a> (uchar c, uchar index)</td></tr>
<tr class="memdesc:adf0446501d5eb553d8f2e4f488feec53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a regular expression recognizing the language {a_n} for an input letter a, subscripted by n.  <br /></td></tr>
<tr class="separator:adf0446501d5eb553d8f2e4f488feec53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028ab559aab5b6f0bac1ecbc2169e8e1" id="r_a028ab559aab5b6f0bac1ecbc2169e8e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregexp.html">regexp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a028ab559aab5b6f0bac1ecbc2169e8e1">reg_letter_symbolic</a> (uchar c, uchar number)</td></tr>
<tr class="memdesc:a028ab559aab5b6f0bac1ecbc2169e8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a regular expression corresponding to the symbolic letter a_{i+k}.  <br /></td></tr>
<tr class="separator:a028ab559aab5b6f0bac1ecbc2169e8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d309c3501a1c5e70611eedaf1ece04b" id="r_a0d309c3501a1c5e70611eedaf1ece04b"><td class="memItemLeft" align="right" valign="top"><a id="a0d309c3501a1c5e70611eedaf1ece04b" name="a0d309c3501a1c5e70611eedaf1ece04b"></a>
<a class="el" href="structregexp.html">regexp</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>reg_var_symbolic</b> (char *s, uchar number)</td></tr>
<tr class="separator:a0d309c3501a1c5e70611eedaf1ece04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d508ba6c047b2d424a70d74302118d7" id="r_a4d508ba6c047b2d424a70d74302118d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregexp.html">regexp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d508ba6c047b2d424a70d74302118d7">reg_union</a> (<a class="el" href="structregexp.html">regexp</a> *, <a class="el" href="structregexp.html">regexp</a> *)</td></tr>
<tr class="memdesc:a4d508ba6c047b2d424a70d74302118d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two regular expressions with the union operator.  <br /></td></tr>
<tr class="separator:a4d508ba6c047b2d424a70d74302118d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1153f9338e818d7e1dd9f8774326ea94" id="r_a1153f9338e818d7e1dd9f8774326ea94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregexp.html">regexp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1153f9338e818d7e1dd9f8774326ea94">reg_inter</a> (<a class="el" href="structregexp.html">regexp</a> *, <a class="el" href="structregexp.html">regexp</a> *)</td></tr>
<tr class="memdesc:a1153f9338e818d7e1dd9f8774326ea94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two regular expressions with the intersection operator.  <br /></td></tr>
<tr class="separator:a1153f9338e818d7e1dd9f8774326ea94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3711cc9ec44c603335fdf2813edee1" id="r_aaa3711cc9ec44c603335fdf2813edee1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregexp.html">regexp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa3711cc9ec44c603335fdf2813edee1">reg_concat</a> (<a class="el" href="structregexp.html">regexp</a> *, <a class="el" href="structregexp.html">regexp</a> *)</td></tr>
<tr class="memdesc:aaa3711cc9ec44c603335fdf2813edee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two regular expressions with the concatenation operator.  <br /></td></tr>
<tr class="separator:aaa3711cc9ec44c603335fdf2813edee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4524f0d6eb869160daaf3b2eacd7d8" id="r_a1d4524f0d6eb869160daaf3b2eacd7d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregexp.html">regexp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d4524f0d6eb869160daaf3b2eacd7d8">reg_star</a> (<a class="el" href="structregexp.html">regexp</a> *)</td></tr>
<tr class="memdesc:a1d4524f0d6eb869160daaf3b2eacd7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Kleene star operator to a regular expression.  <br /></td></tr>
<tr class="separator:a1d4524f0d6eb869160daaf3b2eacd7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a1c03c92d984abe2b8124abd7ae053" id="r_a62a1c03c92d984abe2b8124abd7ae053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregexp.html">regexp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62a1c03c92d984abe2b8124abd7ae053">reg_plus</a> (<a class="el" href="structregexp.html">regexp</a> *)</td></tr>
<tr class="memdesc:a62a1c03c92d984abe2b8124abd7ae053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Kleene plus operator to a regular expression.  <br /></td></tr>
<tr class="separator:a62a1c03c92d984abe2b8124abd7ae053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db57665ab834362e57afb076bb9b55c" id="r_a5db57665ab834362e57afb076bb9b55c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregexp.html">regexp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5db57665ab834362e57afb076bb9b55c">reg_complement</a> (<a class="el" href="structregexp.html">regexp</a> *)</td></tr>
<tr class="memdesc:a5db57665ab834362e57afb076bb9b55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the complement operator to a regular expression.  <br /></td></tr>
<tr class="separator:a5db57665ab834362e57afb076bb9b55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecb65c2ab8aefcff5d18b610bb7d12b" id="r_a7ecb65c2ab8aefcff5d18b610bb7d12b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ecb65c2ab8aefcff5d18b610bb7d12b">reg_print</a> (<a class="el" href="structregexp.html">regexp</a> *)</td></tr>
<tr class="memdesc:a7ecb65c2ab8aefcff5d18b610bb7d12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays a regular expression on the standard output stream.  <br /></td></tr>
<tr class="separator:a7ecb65c2ab8aefcff5d18b610bb7d12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad463aec6af3f82a2b1fe9fca1e56b666" id="r_ad463aec6af3f82a2b1fe9fca1e56b666"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad463aec6af3f82a2b1fe9fca1e56b666">reg_symbolic_loops</a> (<a class="el" href="structregexp.html">regexp</a> *, ushort, uchar, bool *)</td></tr>
<tr class="memdesc:ad463aec6af3f82a2b1fe9fca1e56b666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes information on the symbolic variables of a regular expression.  <br /></td></tr>
<tr class="separator:ad463aec6af3f82a2b1fe9fca1e56b666"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a06077d10cbe197b94c51dfa686c39a46" id="r_a06077d10cbe197b94c51dfa686c39a46"><td class="memItemLeft" align="right" valign="top"><a id="a06077d10cbe197b94c51dfa686c39a46" name="a06077d10cbe197b94c51dfa686c39a46"></a>
short&#160;</td><td class="memItemRight" valign="bottom"><b>symbolic_count</b></td></tr>
<tr class="memdesc:a06077d10cbe197b94c51dfa686c39a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global variable corresponding to the number of symbolic variables which are currently allowed (set to zero if no symbolic variables are allowed). <br /></td></tr>
<tr class="separator:a06077d10cbe197b94c51dfa686c39a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab037eb418b5068a691e2f98854ced361" id="r_ab037eb418b5068a691e2f98854ced361"><td class="memItemLeft" align="right" valign="top"><a id="ab037eb418b5068a691e2f98854ced361" name="ab037eb418b5068a691e2f98854ced361"></a>
char **&#160;</td><td class="memItemRight" valign="bottom"><b>symbolic_names</b></td></tr>
<tr class="memdesc:ab037eb418b5068a691e2f98854ced361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global array assigning its name to each symbolic variable index (its size is symbolic_count). <br /></td></tr>
<tr class="separator:ab037eb418b5068a691e2f98854ced361"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of regular expressions. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a945e1b6cec6225bade72691d362c68fa" name="a945e1b6cec6225bade72691d362c68fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945e1b6cec6225bade72691d362c68fa">&#9670;&#160;</a></span>regelem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a945e1b6cec6225bade72691d362c68fa">regelem</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operator available in an extended regular expression. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a945e1b6cec6225bade72691d362c68faa2f0d18fc0d0fa4a6cd92dc328501874d" name="a945e1b6cec6225bade72691d362c68faa2f0d18fc0d0fa4a6cd92dc328501874d"></a>EMPTY&#160;</td><td class="fielddoc"><p>Empty language. </p>
</td></tr>
<tr><td class="fieldname"><a id="a945e1b6cec6225bade72691d362c68faa1fa5920d8d419e0b8036e2dbada9a882" name="a945e1b6cec6225bade72691d362c68faa1fa5920d8d419e0b8036e2dbada9a882"></a>EPSILON&#160;</td><td class="fielddoc"><p>Empty word. </p>
</td></tr>
<tr><td class="fieldname"><a id="a945e1b6cec6225bade72691d362c68faa4618cf21306b3c647741afa7ebefcab8" name="a945e1b6cec6225bade72691d362c68faa4618cf21306b3c647741afa7ebefcab8"></a>CHAR&#160;</td><td class="fielddoc"><p>Single letter. </p>
</td></tr>
<tr><td class="fieldname"><a id="a945e1b6cec6225bade72691d362c68faa232dbc82ab82a68986004c87d9b59118" name="a945e1b6cec6225bade72691d362c68faa232dbc82ab82a68986004c87d9b59118"></a>SYCHAR&#160;</td><td class="fielddoc"><p>Symbolic letter. </p>
</td></tr>
<tr><td class="fieldname"><a id="a945e1b6cec6225bade72691d362c68faac603be6458810921e4e3b03672fc1ea3" name="a945e1b6cec6225bade72691d362c68faac603be6458810921e4e3b03672fc1ea3"></a>SYVAR&#160;</td><td class="fielddoc"><p>Symbolic variable. </p>
</td></tr>
<tr><td class="fieldname"><a id="a945e1b6cec6225bade72691d362c68faa4ad40322037d6d371dca3e5cf993f5dc" name="a945e1b6cec6225bade72691d362c68faa4ad40322037d6d371dca3e5cf993f5dc"></a>WORD&#160;</td><td class="fielddoc"><p>Single word. </p>
</td></tr>
<tr><td class="fieldname"><a id="a945e1b6cec6225bade72691d362c68faa4cf5e96eb7880eb38df303a6e5759afd" name="a945e1b6cec6225bade72691d362c68faa4cf5e96eb7880eb38df303a6e5759afd"></a>UNION&#160;</td><td class="fielddoc"><p>Union of two expressions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a945e1b6cec6225bade72691d362c68faa5efa5610d5a2c5e9123d6894dd72e335" name="a945e1b6cec6225bade72691d362c68faa5efa5610d5a2c5e9123d6894dd72e335"></a>INTER&#160;</td><td class="fielddoc"><p>Intersection of two expressions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a945e1b6cec6225bade72691d362c68faa09a24ada4cada9fedf84fbcfd5dc0511" name="a945e1b6cec6225bade72691d362c68faa09a24ada4cada9fedf84fbcfd5dc0511"></a>COMPLEMENT&#160;</td><td class="fielddoc"><p>Complement of an expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a945e1b6cec6225bade72691d362c68faa9044fbb1b4b9307bcd680468a58c22f2" name="a945e1b6cec6225bade72691d362c68faa9044fbb1b4b9307bcd680468a58c22f2"></a>CONCAT&#160;</td><td class="fielddoc"><p>Concatenation of two expressions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a945e1b6cec6225bade72691d362c68faa9d398750ed310ae69cd070016810e4dc" name="a945e1b6cec6225bade72691d362c68faa9d398750ed310ae69cd070016810e4dc"></a>STAR&#160;</td><td class="fielddoc"><p>Kleene star of an expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a945e1b6cec6225bade72691d362c68faa87fe59ef12c3d13dc2a4d14c9b16c1f9" name="a945e1b6cec6225bade72691d362c68faa87fe59ef12c3d13dc2a4d14c9b16c1f9"></a>PLUS&#160;</td><td class="fielddoc"><p>Kleene plus of an expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a945e1b6cec6225bade72691d362c68faac157bdf0b85a40d2619cbc8bc1ae5fe2" name="a945e1b6cec6225bade72691d362c68faac157bdf0b85a40d2619cbc8bc1ae5fe2"></a>NONE&#160;</td><td class="fielddoc"><p>Used for simplifying the display. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afc822beda3f58d0f381de94ef6478d8a" name="afc822beda3f58d0f381de94ef6478d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc822beda3f58d0f381de94ef6478d8a">&#9670;&#160;</a></span>display_syletter_utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint display_syletter_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsyletter.html">syletter</a></td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays a symbolic letter on a given stream: UTF8 version for the indices. </p>
<dl class="section return"><dt>Returns</dt><dd>The length of the displayed letter. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The symbolic letter.  </td></tr>
    <tr><td class="paramname">out</td><td>The stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1e30e80bbc958492e10d8bd761ee096" name="aa1e30e80bbc958492e10d8bd761ee096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e30e80bbc958492e10d8bd761ee096">&#9670;&#160;</a></span>display_syvar_utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint display_syvar_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsyvariable.html">syvariable</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays a symbolic variable on a given stream: UTF8 version for the indices. </p>
<dl class="section attention"><dt>Attention</dt><dd>The variable name is taken from the global array symbolic_names.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the displayed variable. </dd></dl>

</div>
</div>
<a id="a5db57665ab834362e57afb076bb9b55c" name="a5db57665ab834362e57afb076bb9b55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db57665ab834362e57afb076bb9b55c">&#9670;&#160;</a></span>reg_complement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregexp.html">regexp</a> * reg_complement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the complement operator to a regular expression. </p>
<dl class="section attention"><dt>Attention</dt><dd>The input expression is not copied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting regular expression. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa3711cc9ec44c603335fdf2813edee1" name="aaa3711cc9ec44c603335fdf2813edee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3711cc9ec44c603335fdf2813edee1">&#9670;&#160;</a></span>reg_concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregexp.html">regexp</a> * reg_concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines two regular expressions with the concatenation operator. </p>
<dl class="section attention"><dt>Attention</dt><dd>The two input expressions are not copied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting regular expression. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left expression.  </td></tr>
    <tr><td class="paramname">right</td><td>The right expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a420113f0cc33a6dc7b6eb2abd3ac9a43" name="a420113f0cc33a6dc7b6eb2abd3ac9a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420113f0cc33a6dc7b6eb2abd3ac9a43">&#9670;&#160;</a></span>reg_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregexp.html">regexp</a> * reg_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy of a regular expression. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the input regular expression. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The regular expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ba9e7fdf196326ddc67a7e7b8ce221b" name="a2ba9e7fdf196326ddc67a7e7b8ce221b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba9e7fdf196326ddc67a7e7b8ce221b">&#9670;&#160;</a></span>reg_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregexp.html">regexp</a> * reg_empty </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a regular expression recognizing the empty language. </p>
<dl class="section return"><dt>Returns</dt><dd>The regular expression </dd></dl>

</div>
</div>
<a id="a2092d5f621e571c562a90c097e7e56c9" name="a2092d5f621e571c562a90c097e7e56c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2092d5f621e571c562a90c097e7e56c9">&#9670;&#160;</a></span>reg_epsilon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregexp.html">regexp</a> * reg_epsilon </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a regular expression recognizing the language {ε}. </p>
<dl class="section return"><dt>Returns</dt><dd>The regular expression. </dd></dl>

</div>
</div>
<a id="aa4c7ffc70fec6309a28b393380d505f0" name="aa4c7ffc70fec6309a28b393380d505f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c7ffc70fec6309a28b393380d505f0">&#9670;&#160;</a></span>reg_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reg_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release of a regular expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The regular expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2782e3c0fdb39fe6d1181a5775e240a" name="ab2782e3c0fdb39fe6d1181a5775e240a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2782e3c0fdb39fe6d1181a5775e240a">&#9670;&#160;</a></span>reg_has_symbolic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reg_has_symbolic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>exp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if a regular expression contains a symbolic node. </p>
<dl class="section return"><dt>Returns</dt><dd>A Boolean indicating whether the regular expression contains a symbolic node. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp</td><td>The regular expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1153f9338e818d7e1dd9f8774326ea94" name="a1153f9338e818d7e1dd9f8774326ea94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1153f9338e818d7e1dd9f8774326ea94">&#9670;&#160;</a></span>reg_inter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregexp.html">regexp</a> * reg_inter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines two regular expressions with the intersection operator. </p>
<dl class="section attention"><dt>Attention</dt><dd>The two input expressions are not copied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting regular expression. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left expression.  </td></tr>
    <tr><td class="paramname">right</td><td>The right expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed9ac023e7d3f1ceb95c4ca5d3386ff7" name="aed9ac023e7d3f1ceb95c4ca5d3386ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9ac023e7d3f1ceb95c4ca5d3386ff7">&#9670;&#160;</a></span>reg_issimple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reg_issimple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>exp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if a regular expression is simple. </p>
<dl class="section remark"><dt>Remarks</dt><dd>A regular expression is simple if and only if it does not contain the operators for intersection and complement.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A Boolean indicating whether the regular expression is simple. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp</td><td>The regular expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e86a288e33a52e8e0fd42eaf76435ab" name="a1e86a288e33a52e8e0fd42eaf76435ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e86a288e33a52e8e0fd42eaf76435ab">&#9670;&#160;</a></span>reg_letter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregexp.html">regexp</a> * reg_letter </td>
          <td>(</td>
          <td class="paramtype">uchar</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a regular expression recognizing the language {a} for an input letter a. </p>
<dl class="section return"><dt>Returns</dt><dd>The regular expression. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The letter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f5a5a4ec95a5e07499917e03b8e37f6" name="a6f5a5a4ec95a5e07499917e03b8e37f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5a5a4ec95a5e07499917e03b8e37f6">&#9670;&#160;</a></span>reg_letter_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregexp.html">regexp</a> * reg_letter_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structletter.html">letter</a></td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a regular expression recognizing the language {a} for an input letter a. Extended version. </p>
<dl class="section return"><dt>Returns</dt><dd>The regular expression. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The letter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf0446501d5eb553d8f2e4f488feec53" name="adf0446501d5eb553d8f2e4f488feec53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0446501d5eb553d8f2e4f488feec53">&#9670;&#160;</a></span>reg_letter_numbered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregexp.html">regexp</a> * reg_letter_numbered </td>
          <td>(</td>
          <td class="paramtype">uchar</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a regular expression recognizing the language {a_n} for an input letter a, subscripted by n. </p>
<dl class="section return"><dt>Returns</dt><dd>The regular expression. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The letter.  </td></tr>
    <tr><td class="paramname">index</td><td>The number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a028ab559aab5b6f0bac1ecbc2169e8e1" name="a028ab559aab5b6f0bac1ecbc2169e8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028ab559aab5b6f0bac1ecbc2169e8e1">&#9670;&#160;</a></span>reg_letter_symbolic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregexp.html">regexp</a> * reg_letter_symbolic </td>
          <td>(</td>
          <td class="paramtype">uchar</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar</td>          <td class="paramname"><span class="paramname"><em>number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a regular expression corresponding to the symbolic letter a_{i+k}. </p>
<dl class="section return"><dt>Returns</dt><dd>The regular expression. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The letter.  </td></tr>
    <tr><td class="paramname">number</td><td>The number k. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62a1c03c92d984abe2b8124abd7ae053" name="a62a1c03c92d984abe2b8124abd7ae053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a1c03c92d984abe2b8124abd7ae053">&#9670;&#160;</a></span>reg_plus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregexp.html">regexp</a> * reg_plus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the Kleene plus operator to a regular expression. </p>
<dl class="section attention"><dt>Attention</dt><dd>The input expression is not copied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting regular expression. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ecb65c2ab8aefcff5d18b610bb7d12b" name="a7ecb65c2ab8aefcff5d18b610bb7d12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecb65c2ab8aefcff5d18b610bb7d12b">&#9670;&#160;</a></span>reg_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reg_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays a regular expression on the standard output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d4524f0d6eb869160daaf3b2eacd7d8" name="a1d4524f0d6eb869160daaf3b2eacd7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4524f0d6eb869160daaf3b2eacd7d8">&#9670;&#160;</a></span>reg_star()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregexp.html">regexp</a> * reg_star </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the Kleene star operator to a regular expression. </p>
<dl class="section attention"><dt>Attention</dt><dd>The input expression is not copied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting regular expression. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad463aec6af3f82a2b1fe9fca1e56b666" name="ad463aec6af3f82a2b1fe9fca1e56b666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad463aec6af3f82a2b1fe9fca1e56b666">&#9670;&#160;</a></span>reg_symbolic_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reg_symbolic_loops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>exp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort</td>          <td class="paramname"><span class="paramname"><em>max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar</td>          <td class="paramname"><span class="paramname"><em>num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>cycle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes information on the symbolic variables of a regular expression. </p>
<p>A list of symbolic variable names is given as input. The function checks whether all names in the expressions are in this set. Furthermore, for each name, it checks if there exists an occurence of this name with the index 0.</p>
<dl class="section return"><dt>Returns</dt><dd>A Boolean indicating whether all names in the expression are in the input set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp</td><td>The regular expression.  </td></tr>
    <tr><td class="paramname">max</td><td>The maximum decrement.  </td></tr>
    <tr><td class="paramname">num</td><td>The number of names in the input set.  </td></tr>
    <tr><td class="paramname">cycle</td><td>Used to return the names which occur with the index 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d508ba6c047b2d424a70d74302118d7" name="a4d508ba6c047b2d424a70d74302118d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d508ba6c047b2d424a70d74302118d7">&#9670;&#160;</a></span>reg_union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregexp.html">regexp</a> * reg_union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structregexp.html">regexp</a> *</td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines two regular expressions with the union operator. </p>
<dl class="section attention"><dt>Attention</dt><dd>The two input expressions are not copied.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting regular expression. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left expression.  </td></tr>
    <tr><td class="paramname">right</td><td>The right expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a935e36a4d7114dc9f40109f1b234ba66" name="a935e36a4d7114dc9f40109f1b234ba66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935e36a4d7114dc9f40109f1b234ba66">&#9670;&#160;</a></span>symbolic_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short symbolic_index </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>varname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the index of a symbolic variable name in the array symbolic_names. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the symbolic variable name. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varname</td><td>The symbolic variable name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="regexp_8h.html">regexp.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
